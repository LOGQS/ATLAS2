import React, { useState, useCallback, useEffect } from 'react';
import '../../styles/chat/ContextWindow.css';
import { apiUrl } from '../../config/api';
import logger from '../../utils/core/logger';
import Tooltip from '../ui/Tooltip';
import type {
  ContextAnalysisResponse,
  ContextAnalysisData,
  RequestAnalysis,
  TokenSegment
} from '../../types/contextAnalysis';

interface ContextWindowProps {
  isOpen: boolean;
  onClose: () => void;
  chatId?: string;
}

type RoleType = 'all' | 'router' | 'planner' | 'assistant' | 'agent_tools';
type TabType = 'aggregate' | 'analysis';

const tooltipDescriptions = {
  totalTokens: 'Sum of estimated tokens (predicted before API calls) + actual tokens (reported by API after calls). This shows the complete token consumption for this role across all requests in this chat.',
  avgPerCall: 'Average of (estimated + actual) tokens per API call. Calculated as: (total estimated + total actual) / number of calls. Shows typical token consumption per request for this role.',
  estimatedPerCall: 'Average INPUT tokens estimated BEFORE each API call. This is what we predicted the prompt would cost (system prompt + chat history + user message + file attachments) before sending to the API.',
  actualPerCall: 'Average TOTAL tokens (input + output) reported by the API AFTER each call. This is what the provider actually charged including both the prompt we sent and the response it generated.',
  lastUsed: 'Timestamp of when this role last made an API call. Helps track recency of different model interactions (router decisions, task planning, assistant responses, agent tool calls).',

  roleBadge: 'The function of this model call: ROUTER (decides which model/route to use), PLANNER (breaks tasks into steps), ASSISTANT (generates chat responses), or AGENT_TOOL (executes autonomous tool calls).',
  providerModel: 'The exact provider (Gemini/Groq/OpenRouter) and model (e.g., gemini-2.5-flash, llama-3.3-70b) that processed THIS specific request. Router uses gemini-2.5-flash-lite, assistant uses the model chosen by router.',
  inputMetric: 'Total tokens in the COMPLETE INPUT PROMPT sent to the model for this request. Includes: system prompt + chat history + user message + file attachments. This is what you "pay" for the question.',
  outputMetric: 'Total tokens GENERATED by the model in its response to this request. This is what you "pay" for the answer. Only shown if the model produced output (router and planner don\'t always have output tokens).',
  requestNote: 'Metadata about this specific request: selected route, available tools count, tokenization method used, actual token counts from API. Helps understand how this request was processed.',

  'System Instructions': 'The opening template of the router prompt. Contains: "You are a router. Classify the request into exactly one route from the list below." Explains the router\'s job and rules for selecting routes.',
  'Available Routes': 'List of ALL routing options the router can choose from. Each route has: route_name, route_description, route_context. Example: "simple: For straightforward questions (general conversation)" or "complex: For multi-step tasks (requires planning)". Router picks ONE from this list.',
  'Context Preface': 'Bridge text between Available Routes and Conversation Context. Says: "## AVAILABLE INFORMATION: The request context is here:". Introduces the context that will help router decide which route to pick.',
  'Conversation Context': 'The ACTUAL chat history (all previous messages) + the current user question. This is what the router analyzes to determine which route fits best. Long conversations = more tokens here.',
  'Response Format': 'Instructions for HOW the router must format its response. Requires XML tags: <ROUTE><CONSIDER>...<REASON>...<CHOICE>route_name</CHOICE></ROUTE>. Ensures router output is parseable by the system.',

  'Available Tools': 'List of ALL tools the planner can use in its plan. Each tool has: name, description, parameters. Examples: file_read, web_search, code_execute. Planner uses these to break tasks into actionable steps.',
  'Task Format': 'Instructions for how planner should structure its output plan. Defines JSON schema, step format, tool usage syntax. Ensures planner generates valid, executable plans.',
  'User Request': 'The exact message the user sent that needs to be planned. Planner breaks THIS down into steps. In router: this is part of Conversation Context. In planner: this is the standalone task to decompose.',
  'Response Directive': 'Final instructions telling planner what to output. Typically: "Generate a plan in the specified JSON format." Reinforces output structure requirements.',

  'System Prompt': 'The base personality/behavior instructions for the assistant. Set at chat creation. Examples: "You are a helpful coding assistant" or "You are a creative writing partner". Prepended to EVERY assistant request.',
  'Chat History (X messages)': 'ALL previous messages in this conversation (both user and assistant). Gives assistant context about what was discussed before. More messages = more tokens = higher cost. Each message adds ~50-200 tokens typically.',
  'User Message': 'The CURRENT question/request from the user that the assistant needs to respond to. This is the actual user input being answered right now.',
  'File Attachments (X files)': 'Files attached to the current message (images, PDFs, code files). Each file is converted to tokens: images ~258 tokens, text files vary by length. Included in assistant\'s input so it can reference file contents.',

  'Assistant Response': 'The text content the assistant generated in reply to the user\'s message. This is the visible response you see in the chat. Token count = what you paid for generating this answer.',
  'Internal Reasoning': 'The assistant\'s hidden thought process (thinking/reasoning tokens). Some models expose their step-by-step reasoning before generating the final answer. You pay for these tokens even though they\'re not shown in the chat.',

  segmentTokenCount: 'Exact number of tokens consumed by THIS segment. Each token costs money, so this shows which parts of your prompt are expensive.',
  methodBadge: 'How tokens were counted: 🎯 Native (provider API call - always accurate), 🔧 TikToken (OpenAI encoding - accurate for compatible models), ≈ Approximation (4 chars/token - used as fallback).',
  estimatedBadge: 'Token count was calculated locally before sending to API, not reported by provider. Less accurate than native counts but still useful for budgeting.',
  charCount: 'Character count of this segment. Rule of thumb: ~4 characters = 1 token for English text. Helps estimate token cost when native counting unavailable.',
  fileDetail: 'One file attached to this request. Token count based on file type: images ~258 tokens (Gemini vision API), text/code files counted by content length.',

  systemPromptSection: 'The BASE INSTRUCTIONS prepended to EVERY model request in this chat. Set once when chat starts, then included in all subsequent requests. Examples: "You are a helpful assistant", custom personality/behavior rules.',
  systemPromptTokens: 'Tokens consumed by the system prompt in EVERY SINGLE REQUEST. Since it\'s included in all calls, this cost multiplies (e.g., 100 tokens × 10 requests = 1000 tokens total). Shorter system prompts save money on long conversations.',
};

interface TokenBreakdown {
  estimated: number;
  actual: number;
  calls: number;
}

interface RoleInfo {
  provider: string;
  model: string;
  method: string;
  last_used: string;
}

interface MessageBreakdown {
  index: number;
  role: string;
  content_preview: string;
  tokens: number;
}

interface FileBreakdown {
  file: string;
  estimated_tokens: number;
  method: string;
}

interface BreakdownDetails {
  system_prompt_tokens: number;
  system_prompt_present: boolean;
  history_messages_count: number;
  history_total_tokens: number;
  per_message_breakdown: MessageBreakdown[];
  current_message_tokens: number;
  current_message_length: number;
  file_count: number;
  file_breakdown: FileBreakdown[];
}

interface EstimateData {
  role: string;
  estimated_tokens: {
    system_prompt: number;
    chat_history: number;
    current_message: number;
    file_attachments: number;
    total: number;
  };
  method: string;
  model: string;
  provider: string;
  breakdown_details: BreakdownDetails;
}

interface TokenUsageData {
  chat_id: string;
  roles: {
    router: TokenBreakdown;
    planner: TokenBreakdown;
    assistant: TokenBreakdown;
    agent_tools: TokenBreakdown;
  };
  role_info: Record<string, RoleInfo>;
  total_tokens: number;
  note?: string;
}

const LoadingState: React.FC<{ message: string }> = ({ message }) => (
  <div className="context-loading">
    <div className="context-loading-spinner"></div>
    <p>{message}</p>
  </div>
);

const ErrorState: React.FC<{ error: string; title: string; onRetry: () => void }> = ({ error, title, onRetry }) => (
  <div className="context-error">
    <div className="context-error-icon">⚠</div>
    <h3>{title}</h3>
    <p>{error}</p>
    <button className="context-retry-button" onClick={onRetry}>
      Retry
    </button>
  </div>
);

const EmptyState: React.FC = () => (
  <div className="context-empty">
    <div className="placeholder-icon context-icon-large"></div>
    <h3>No Chat Selected</h3>
    <p>Select a chat to view token usage and context information</p>
  </div>
);

const TokenCard: React.FC<{ title: string; value: number; subtitle?: string }> = ({ title, value, subtitle }) => (
  <div className="token-card">
    <div className="token-card-header">{title}</div>
    <div className="token-card-value">{value.toLocaleString()}</div>
    {subtitle && <div className="token-card-subtitle">{subtitle}</div>}
  </div>
);

const getMethodBadgeClass = (method: string): string => {
  if (method.includes('native')) return 'method-badge-native';
  if (method.includes('tiktoken')) return 'method-badge-tiktoken';
  return 'method-badge-fallback';
};

const getMethodLabel = (method: string): string => {
  if (method.includes('native')) return '🎯 Native';
  if (method.includes('tiktoken')) return '🔧 TikToken';
  return '≈ Approximation';
};

const RoleBreakdown: React.FC<{
  role: string;
  data: TokenBreakdown;
  info?: RoleInfo;
  onExpand?: () => void;
  expanded?: boolean;
}> = ({ role, data, info, onExpand, expanded }) => {
  const totalTokens = data.estimated + data.actual;
  const avgPerCall = data.calls > 0 ? Math.round(totalTokens / data.calls) : 0;
  const estimatedPerCall = data.calls > 0 ? Math.round(data.estimated / data.calls) : 0;
  const actualPerCall = data.calls > 0 ? Math.round(data.actual / data.calls) : 0;

  return (
    <div className="role-breakdown">
      <div className="role-breakdown-header" onClick={onExpand} style={{ cursor: onExpand ? 'pointer' : 'default' }}>
        <div className="role-header-left">
          <span className="role-badge">{role}</span>
          <span className="role-calls">{data.calls} {data.calls === 1 ? 'call' : 'calls'}</span>
        </div>
        {onExpand && (
          <span className="role-expand-icon">{expanded ? '▼' : '▶'}</span>
        )}
      </div>

      {info && (
        <div className="role-info-bar">
          <span className="role-info-item">
            <span className="role-info-label">Provider:</span>
            <span className="role-info-value">{info.provider}</span>
          </span>
          <span className="role-info-item">
            <span className="role-info-label">Model:</span>
            <span className="role-info-value">{info.model}</span>
          </span>
          <span className={`method-badge ${getMethodBadgeClass(info.method)}`}>
            {getMethodLabel(info.method)}
          </span>
        </div>
      )}

      <div className="role-tokens">
        <div className="role-token-item">
          <span className="role-token-label">Estimated:</span>
          <span className="role-token-value">{data.estimated.toLocaleString()}</span>
        </div>
        <div className="role-token-item">
          <span className="role-token-label">Actual:</span>
          <span className="role-token-value">{data.actual > 0 ? data.actual.toLocaleString() : 'N/A'}</span>
        </div>
      </div>

      {expanded && (
        <div className="role-expanded-details">
          <Tooltip content={tooltipDescriptions.totalTokens}>
            <div className="expanded-detail-row">
              <span className="detail-label">Total Tokens:</span>
              <span className="detail-value">{totalTokens.toLocaleString()}</span>
            </div>
          </Tooltip>
          <Tooltip content={tooltipDescriptions.avgPerCall}>
            <div className="expanded-detail-row">
              <span className="detail-label">Avg per Call:</span>
              <span className="detail-value">{avgPerCall.toLocaleString()}</span>
            </div>
          </Tooltip>
          {data.calls > 0 && (
            <>
              <Tooltip content={tooltipDescriptions.estimatedPerCall}>
                <div className="expanded-detail-row">
                  <span className="detail-label">Estimated/Call:</span>
                  <span className="detail-value">{estimatedPerCall.toLocaleString()}</span>
                </div>
              </Tooltip>
              {data.actual > 0 && (
                <Tooltip content={tooltipDescriptions.actualPerCall}>
                  <div className="expanded-detail-row">
                    <span className="detail-label">Actual/Call:</span>
                    <span className="detail-value">{actualPerCall.toLocaleString()}</span>
                  </div>
                </Tooltip>
              )}
            </>
          )}
          {info?.last_used && (
            <Tooltip content={tooltipDescriptions.lastUsed}>
              <div className="expanded-detail-row">
                <span className="detail-label">Last Used:</span>
                <span className="detail-value">{new Date(info.last_used).toLocaleString()}</span>
              </div>
            </Tooltip>
          )}
        </div>
      )}
    </div>
  );
};

const SegmentCard: React.FC<{ segment: TokenSegment; expanded?: boolean; onToggle?: () => void }> = ({ segment, expanded, onToggle }) => {
  const labelTooltip = tooltipDescriptions[segment.label as keyof typeof tooltipDescriptions];

  return (
    <div className="segment-card">
      <div className="segment-card-header" onClick={onToggle} style={{ cursor: onToggle ? 'pointer' : 'default' }}>
        <div className="segment-card-title">
          {labelTooltip ? (
            <Tooltip content={labelTooltip}>
              <span className="segment-label">{segment.label}</span>
            </Tooltip>
          ) : (
            <span className="segment-label">{segment.label}</span>
          )}
          <Tooltip content={tooltipDescriptions.segmentTokenCount}>
            <span className="segment-tokens">{segment.tokens.toLocaleString()} tokens</span>
          </Tooltip>
        </div>
        {onToggle && <span className="segment-expand-icon">{expanded ? '▼' : '▶'}</span>}
      </div>
      <div className="segment-card-meta">
        <Tooltip content={tooltipDescriptions.methodBadge}>
          <span className={`method-badge ${getMethodBadgeClass(segment.method)}`}>
            {getMethodLabel(segment.method)}
          </span>
        </Tooltip>
        {segment.is_estimated && (
          <Tooltip content={tooltipDescriptions.estimatedBadge}>
            <span className="estimated-badge">Estimated</span>
          </Tooltip>
        )}
        {segment.char_count && (
          <Tooltip content={tooltipDescriptions.charCount}>
            <span className="char-count">{segment.char_count.toLocaleString()} chars</span>
          </Tooltip>
        )}
      </div>
      {expanded && segment.details && segment.details.length > 0 && (
        <div className="segment-details">
          {segment.details.map((detail, idx) => (
            <Tooltip key={idx} content={tooltipDescriptions.fileDetail}>
              <div className="segment-detail-item">
                <span className="detail-file">{detail.file}</span>
                <span className="detail-tokens">{detail.estimated_tokens} tokens</span>
                <span className={`method-badge small ${getMethodBadgeClass(detail.method)}`}>
                  {getMethodLabel(detail.method)}
                </span>
              </div>
            </Tooltip>
          ))}
        </div>
      )}
    </div>
  );
};

const RequestCard: React.FC<{ request: RequestAnalysis; expanded?: boolean; onToggle?: () => void }> = ({ request, expanded, onToggle }) => (
  <div className={`request-card role-${request.role}`}>
    <div className="request-card-header" onClick={onToggle} style={{ cursor: onToggle ? 'pointer' : 'default' }}>
      <div className="request-header-left">
        <Tooltip content={tooltipDescriptions.roleBadge}>
          <span className={`role-badge ${request.role}`}>{request.role.toUpperCase()}</span>
        </Tooltip>
        <div className="request-title">
          <h4>{request.label}</h4>
          <Tooltip content={tooltipDescriptions.providerModel}>
            <p>{request.provider} · {request.model}</p>
          </Tooltip>
        </div>
      </div>
      <div className="request-header-right">
        <div className="request-metrics">
          <Tooltip content={tooltipDescriptions.inputMetric}>
            <div className="request-metric">
              <span className="metric-label">Input</span>
              <span className="metric-value">{request.input.total.tokens.toLocaleString()}</span>
            </div>
          </Tooltip>
          {request.output && (
            <Tooltip content={tooltipDescriptions.outputMetric}>
              <div className="request-metric">
                <span className="metric-label">Output</span>
                <span className="metric-value">{request.output.total.tokens.toLocaleString()}</span>
              </div>
            </Tooltip>
          )}
        </div>
        {onToggle && <span className="segment-expand-icon">{expanded ? '▼' : '▶'}</span>}
      </div>
    </div>
    {request.notes && request.notes.length > 0 && (
      <div className="request-notes">
        {request.notes.map((note, idx) => (
          <Tooltip key={idx} content={tooltipDescriptions.requestNote}>
            <span className="request-note">{note}</span>
          </Tooltip>
        ))}
      </div>
    )}
    {expanded && (
      <div className="request-breakdown">
        <div className="request-section">
          <h5>Input Breakdown</h5>
          {request.input.segments.map((segment, idx) => (
            <SegmentCard key={idx} segment={segment} />
          ))}
        </div>
        {request.output && (
          <div className="request-section">
            <h5>Output Breakdown</h5>
            {request.output.segments.map((segment, idx) => (
              <SegmentCard key={idx} segment={segment} />
            ))}
          </div>
        )}
      </div>
    )}
  </div>
);

const AnalysisView: React.FC<{
  analysisData: ContextAnalysisData;
  onRefresh: () => void;
}> = ({ analysisData, onRefresh }) => {
  const [expandedRequest, setExpandedRequest] = useState<number | null>(null);

  return (
    <div className="analysis-view">
      {/* System Prompt Section */}
      {analysisData.system_prompt.content && (
        <Tooltip content={tooltipDescriptions.systemPromptSection}>
          <div className="analysis-system-prompt">
            <div className="analysis-section-header">
              <h3>System Prompt</h3>
              <Tooltip content={tooltipDescriptions.systemPromptTokens}>
                <span className="section-token-count">{analysisData.system_prompt.tokens.toLocaleString()} tokens</span>
              </Tooltip>
            </div>
            <div className="system-prompt-meta">
              <Tooltip content={tooltipDescriptions.methodBadge}>
                <span className={`method-badge ${getMethodBadgeClass(analysisData.system_prompt.method)}`}>
                  {getMethodLabel(analysisData.system_prompt.method)}
                </span>
              </Tooltip>
              {analysisData.system_prompt.is_estimated && (
                <Tooltip content={tooltipDescriptions.estimatedBadge}>
                  <span className="estimated-badge">Estimated</span>
                </Tooltip>
              )}
            </div>
            <div className="system-prompt-content">
              <pre>{analysisData.system_prompt.content}</pre>
            </div>
          </div>
        </Tooltip>
      )}

      {/* Requests Section */}
      <div className="analysis-requests">
        <div className="analysis-section-header">
          <h3>Request Breakdown</h3>
          <button className="refresh-analysis-btn" onClick={onRefresh}>
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
              <path d="M21 2v6h-6"/>
              <path d="M3 12a9 9 0 0 1 15-6.7L21 8"/>
              <path d="M3 22v-6h6"/>
              <path d="M21 12a9 9 0 0 1-15 6.7L3 16"/>
            </svg>
            Refresh Analysis
          </button>
        </div>

        {analysisData.requests.length === 0 ? (
          <div className="analysis-empty">
            <p>No requests found for this interaction</p>
          </div>
        ) : (
          <div className="request-cards">
            {analysisData.requests.map((request, idx) => (
              <RequestCard
                key={idx}
                request={request}
                expanded={expandedRequest === idx}
                onToggle={() => setExpandedRequest(expandedRequest === idx ? null : idx)}
              />
            ))}
          </div>
        )}
      </div>

      {/* Footer */}
      <div className="analysis-footer">
        <span className="analysis-timestamp">
          Generated at {new Date(analysisData.generated_at).toLocaleString()}
        </span>
      </div>
    </div>
  );
};

const DetailedBreakdown: React.FC<{ estimate: EstimateData }> = ({ estimate }) => {
  const details = estimate.breakdown_details;

  return (
    <div className="detailed-breakdown">
      <h3>Detailed Token Breakdown</h3>

      {/* Summary Cards */}
      <div className="breakdown-summary-cards">
        <TokenCard title="System Prompt" value={estimate.estimated_tokens.system_prompt} />
        <TokenCard title="Chat History" value={estimate.estimated_tokens.chat_history} />
        <TokenCard title="Current Message" value={estimate.estimated_tokens.current_message} />
        <TokenCard title="File Attachments" value={estimate.estimated_tokens.file_attachments} />
      </div>

      {/* System Prompt Section */}
      {details.system_prompt_present && (
        <div className="breakdown-section">
          <h4>System Prompt</h4>
          <div className="breakdown-item">
            <span className="breakdown-label">Tokens:</span>
            <span className="breakdown-value">{details.system_prompt_tokens.toLocaleString()}</span>
          </div>
          <div className="breakdown-note">
            <span className={`method-badge ${getMethodBadgeClass(estimate.method)}`}>
              {getMethodLabel(estimate.method)}
            </span>
            <span className="breakdown-note-text">
              System prompt includes static and dynamic parts specific to {estimate.role} role
            </span>
          </div>
        </div>
      )}

      {/* Chat History Section */}
      {details.history_messages_count > 0 && (
        <div className="breakdown-section">
          <h4>Chat History ({details.history_messages_count} messages)</h4>
          <div className="message-breakdown-list">
            {details.per_message_breakdown.map((msg) => (
              <div key={msg.index} className="message-breakdown-item">
                <div className="message-breakdown-header">
                  <span className={`message-role-badge ${msg.role}`}>{msg.role}</span>
                  <span className="message-tokens">{msg.tokens} tokens</span>
                </div>
                <div className="message-preview">{msg.content_preview}</div>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Current Message Section */}
      {details.current_message_tokens > 0 && (
        <div className="breakdown-section">
          <h4>Current Message</h4>
          <div className="breakdown-item">
            <span className="breakdown-label">Characters:</span>
            <span className="breakdown-value">{details.current_message_length.toLocaleString()}</span>
          </div>
          <div className="breakdown-item">
            <span className="breakdown-label">Tokens:</span>
            <span className="breakdown-value">{details.current_message_tokens.toLocaleString()}</span>
          </div>
        </div>
      )}

      {/* File Attachments Section */}
      {details.file_count > 0 && (
        <div className="breakdown-section">
          <h4>File Attachments ({details.file_count} files)</h4>
          <div className="file-breakdown-list">
            {details.file_breakdown.map((file, idx) => (
              <div key={idx} className="file-breakdown-item">
                <div className="file-breakdown-header">
                  <span className="file-name">{file.file}</span>
                  <span className="file-tokens">{file.estimated_tokens} tokens</span>
                </div>
                <span className={`method-badge small ${getMethodBadgeClass(file.method)}`}>
                  {getMethodLabel(file.method)}
                </span>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Total */}
      <div className="breakdown-total">
        <span className="breakdown-total-label">Total Estimated Tokens:</span>
        <span className="breakdown-total-value">{estimate.estimated_tokens.total.toLocaleString()}</span>
      </div>
    </div>
  );
};

const ContextWindow: React.FC<ContextWindowProps> = ({
  isOpen,
  onClose,
  chatId
}) => {
  const [activeTab, setActiveTab] = useState<TabType>('aggregate');
  const [selectedRole, setSelectedRole] = useState<RoleType>('all');
  const [tokenData, setTokenData] = useState<TokenUsageData | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const [showCalculator, setShowCalculator] = useState(false);
  const [draftMessage, setDraftMessage] = useState('');
  const [estimateData, setEstimateData] = useState<EstimateData | null>(null);
  const [calculatingEstimate, setCalculatingEstimate] = useState(false);
  const [expandedRole, setExpandedRole] = useState<string | null>(null);

  const [analysisData, setAnalysisData] = useState<ContextAnalysisData | null>(null);
  const [analysisLoading, setAnalysisLoading] = useState(false);
  const [analysisError, setAnalysisError] = useState<string | null>(null);

  const handleAsyncError = useCallback((error: unknown, context: string, fallbackMessage: string) => {
    const errorMsg = error instanceof Error ? error.message : fallbackMessage;
    logger.error(`[ContextWindow] ${context}:`, error);
    setError(errorMsg);
  }, []);

  const handleRoleToggle = useCallback((role: RoleType) => {
    setSelectedRole(role);
    setExpandedRole(null);
  }, []);

  const loadTokenUsage = useCallback(async () => {
    if (!chatId) return;

    setLoading(true);
    setError(null);

    try {
      logger.info(`[ContextWindow] Loading token usage for chat: ${chatId}`);
      const url = apiUrl(`/api/chat/${chatId}/token-usage`);

      const response = await fetch(url);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();

      if (!data.success) {
        throw new Error('Failed to load token usage');
      }

      const tokenUsage: TokenUsageData = {
        chat_id: data.chat_id,
        roles: data.roles,
        role_info: data.role_info || {},
        total_tokens: data.total_tokens,
        note: data.note
      };

      logger.info(`[ContextWindow] Token usage loaded successfully`);
      setTokenData(tokenUsage);

    } catch (err) {
      handleAsyncError(err, 'Error loading token usage', 'Failed to load token usage');
    } finally {
      setLoading(false);
    }
  }, [chatId, handleAsyncError]);

  const calculateTokens = useCallback(async () => {
    if (!chatId || !draftMessage.trim()) {
      setError('Please enter a message to calculate tokens');
      return;
    }

    setCalculatingEstimate(true);
    setError(null);

    try {
      logger.info('[ContextWindow] Calculating tokens for draft message');
      const url = apiUrl(`/api/chat/${chatId}/estimate-tokens`);

      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          message: draftMessage,
          role: 'assistant',
        }),
      });

      const data = await response.json();

      if (data.success) {
        logger.info('[ContextWindow] Estimate received successfully');
        setEstimateData(data.estimation);
      } else {
        setError(data.error || 'Failed to calculate tokens');
      }
    } catch (err) {
      handleAsyncError(err, 'Error calculating tokens', 'Failed to calculate tokens');
    } finally {
      setCalculatingEstimate(false);
    }
  }, [chatId, draftMessage, handleAsyncError]);

  const loadAnalysis = useCallback(async () => {
    if (!chatId) return;

    setAnalysisLoading(true);
    setAnalysisError(null);

    try {
      logger.info(`[ContextWindow] Loading context analysis for chat: ${chatId}`);
      const url = apiUrl(`/api/chats/${chatId}/context-analysis`);

      const response = await fetch(url);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data: ContextAnalysisResponse = await response.json();

      if (!data.success || !data.data) {
        throw new Error(data.error || 'Failed to load context analysis');
      }

      logger.info(`[ContextWindow] Context analysis loaded successfully`);
      setAnalysisData(data.data);

    } catch (err) {
      handleAsyncError(err, 'Error loading context analysis', 'Failed to load context analysis');
      setAnalysisError(err instanceof Error ? err.message : 'Failed to load context analysis');
    } finally {
      setAnalysisLoading(false);
    }
  }, [chatId, handleAsyncError]);

  const handleBackdropClick = useCallback((e: React.MouseEvent) => {
    if (e.target === e.currentTarget) {
      onClose();
    }
  }, [onClose]);

  const handleTabChange = useCallback((tab: TabType) => {
    setActiveTab(tab);
    if (tab === 'analysis' && chatId && !analysisData) {
      loadAnalysis();
    }
  }, [chatId, analysisData, loadAnalysis]);

  useEffect(() => {
    if (isOpen && chatId) {
      loadTokenUsage();
      setActiveTab('aggregate');
      setAnalysisData(null);
    }
  }, [isOpen, chatId, loadTokenUsage]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && isOpen) {
        onClose();
      }
    };

    if (isOpen) {
      document.addEventListener('keydown', handleKeyDown);
    }

    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [isOpen, onClose]);

  if (!isOpen) return null;

  const roles: { key: RoleType; label: string }[] = [
    { key: 'all', label: 'All' },
    { key: 'router', label: 'Router' },
    { key: 'planner', label: 'Planner' },
    { key: 'assistant', label: 'Assistant' },
    { key: 'agent_tools', label: 'Agent Tools' }
  ];

  const getRoleData = () => {
    if (!tokenData) return null;
    if (selectedRole === 'all') return tokenData.roles;
    return { [selectedRole]: tokenData.roles[selectedRole] };
  };

  const getTotalTokens = () => {
    if (!tokenData) return 0;
    if (selectedRole === 'all') return tokenData.total_tokens;
    const roleData = tokenData.roles[selectedRole];
    return roleData.estimated + roleData.actual;
  };

  const roleData = getRoleData();

  return (
    <div className="context-window-overlay" onClick={handleBackdropClick} role="dialog" aria-modal="true" aria-labelledby="context-window-title">
      <div className="context-window">
        <div className="context-window-header">
          <div className="context-window-title">
            <div className="context-window-icon"></div>
            <h2 id="context-window-title">Token Context</h2>
          </div>
          <div className="context-window-controls">
            <button className="context-window-close-btn" onClick={onClose} aria-label="Close context window">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <line x1="18" y1="6" x2="6" y2="18"/>
                <line x1="6" y1="6" x2="18" y2="18"/>
              </svg>
            </button>
          </div>
        </div>

        <div className="context-window-content">
          {!chatId && <EmptyState />}

          {chatId && (
            <>
              {/* Tab Switcher */}
              <div className="context-tabs">
                <button
                  className={`context-tab ${activeTab === 'aggregate' ? 'active' : ''}`}
                  onClick={() => handleTabChange('aggregate')}
                >
                  <span className="tab-icon">📊</span>
                  Aggregate Usage
                </button>
                <button
                  className={`context-tab ${activeTab === 'analysis' ? 'active' : ''}`}
                  onClick={() => handleTabChange('analysis')}
                >
                  <span className="tab-icon">🔍</span>
                  Latest Analysis
                </button>
              </div>

              {/* Aggregate Tab */}
              {activeTab === 'aggregate' && (
                <>
                  <div className="role-selector">
                    {roles.map(role => (
                      <button
                        key={role.key}
                        className={`role-selector-btn ${selectedRole === role.key ? 'active' : ''}`}
                        onClick={() => handleRoleToggle(role.key)}
                      >
                        {role.label}
                      </button>
                    ))}
                  </div>

                  {loading && <LoadingState message="Loading token usage..." />}

                  {error && (
                    <ErrorState
                      error={error}
                      title="Error Loading Token Usage"
                      onRetry={loadTokenUsage}
                    />
                  )}

                  {!loading && !error && tokenData && roleData && (
                <div className="token-data-container">
                  <div className="token-summary">
                    <TokenCard
                      title="Total Tokens"
                      value={getTotalTokens()}
                      subtitle={selectedRole === 'all' ? 'All roles combined' : `${selectedRole} only`}
                    />
                  </div>

                  <div className="role-breakdowns">
                    <h3>Breakdown by Role</h3>
                    {Object.entries(roleData).map(([roleName, roleInfo]) => (
                      <RoleBreakdown
                        key={roleName}
                        role={roleName.replace('_', ' ')}
                        data={roleInfo as TokenBreakdown}
                        info={tokenData.role_info[roleName]}
                        onExpand={() => setExpandedRole(expandedRole === roleName ? null : roleName)}
                        expanded={expandedRole === roleName}
                      />
                    ))}
                  </div>

                  {/* Calculate Current Request Section */}
                  <div className="calculator-section">
                    <button
                      className="calculator-toggle-btn"
                      onClick={() => setShowCalculator(!showCalculator)}
                    >
                      <span className="calculator-icon">🧮</span>
                      Calculate Current Request
                    </button>

                    {showCalculator && (
                      <div className="calculator-panel">
                        <textarea
                          className="calculator-input"
                          placeholder="Enter a draft message to calculate token usage..."
                          value={draftMessage}
                          onChange={(e) => setDraftMessage(e.target.value)}
                          rows={4}
                        />
                        <button
                          className="calculator-submit-btn"
                          onClick={calculateTokens}
                          disabled={calculatingEstimate || !draftMessage.trim()}
                        >
                          {calculatingEstimate ? 'Calculating...' : 'Calculate Tokens'}
                        </button>

                        {estimateData && (
                          <DetailedBreakdown estimate={estimateData} />
                        )}
                      </div>
                    )}
                  </div>

                  {tokenData.note && (
                    <div className="context-note">
                      <div className="context-note-icon">ℹ</div>
                      <p>{tokenData.note}</p>
                    </div>
                  )}

                      <div className="context-actions">
                        <button className="context-refresh-btn" onClick={loadTokenUsage}>
                          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                            <path d="M21 2v6h-6"/>
                            <path d="M3 12a9 9 0 0 1 15-6.7L21 8"/>
                            <path d="M3 22v-6h6"/>
                            <path d="M21 12a9 9 0 0 1-15 6.7L3 16"/>
                          </svg>
                          Refresh
                        </button>
                      </div>
                    </div>
                  )}
                </>
              )}

              {/* Analysis Tab */}
              {activeTab === 'analysis' && (
                <>
                  {analysisLoading && <LoadingState message="Loading latest interaction analysis..." />}

                  {analysisError && (
                    <ErrorState
                      error={analysisError}
                      title="Error Loading Analysis"
                      onRetry={loadAnalysis}
                    />
                  )}

                  {!analysisLoading && !analysisError && analysisData && (
                    <AnalysisView analysisData={analysisData} onRefresh={loadAnalysis} />
                  )}

                  {!analysisLoading && !analysisError && !analysisData && (
                    <div className="analysis-empty">
                      <div className="placeholder-icon context-icon-large"></div>
                      <h3>No Analysis Available</h3>
                      <p>Click refresh to analyze the latest interaction</p>
                      <button className="context-refresh-btn" onClick={loadAnalysis}>
                        Load Analysis
                      </button>
                    </div>
                  )}
                </>
              )}
            </>
          )}
        </div>
      </div>
    </div>
  );
};

export default ContextWindow;
